//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import {ApiBase} from "./api-base";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ProductApiService extends ApiBase {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super();
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * Gets the list of all categories.
   * @return Returns the list of categories.
   */
  getCategories(): Observable<Category[]> {
    let url_ = this.baseUrl + "/api/categories";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCategories(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCategories(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Category[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Category[]>;
    }));
  }

  protected processGetCategories(response: HttpResponseBase): Observable<Category[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Category.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Creates a new category
   * @param body (optional)
   * @return Returns the newly created item.
   */
  createCategory(body?: CreateCategoryDto | undefined): Observable<Category> {
    let url_ = this.baseUrl + "/api/categories";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Category>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Category>;
    }));
  }

  protected processCreateCategory(response: HttpResponseBase): Observable<Category> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = Category.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the item is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Returns an Allow header containing the allowable HTTP methods.
   * @return Success
   */
  categories(): Observable<void> {
    let url_ = this.baseUrl + "/api/categories";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("options", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processCategories(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCategories(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCategories(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves a specific category by its unique identifier.
   * @param categoryId The ID of the category to retrieve.
   * @return Returns the requested category.
   */
  getCategory(categoryId: string): Observable<Category> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Category>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Category>;
    }));
  }

  protected processGetCategory(response: HttpResponseBase): Observable<Category> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Category.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the category with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Updates a specific category by its unique identifier.
   * @param categoryId The ID of the category to update.
   * @param body (optional) The updated category information.
   * @return If the category is successfully updated.
   */
  updateCategory(categoryId: string, body?: UpdateCategoryDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated category is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the category with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid or the category information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Deletes a specific category by its unique identifier.
   * @param categoryId The ID of the category to delete.
   * @return If the category is successfully deleted.
   */
  deleteCategory(categoryId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the category with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Uploads new files.
   * @param productId The ID of the category for product.
   * @return Returns the newly created files names.
   */
  uploadFiles(productId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/files";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadFiles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadFiles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUploadFiles(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 415) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result415: any = null;
        let resultData415 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result415 = ProblemDetails.fromJS(resultData415);
        return throwException("If the header is incorrect.", status, _responseText, _headers, result415);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Deletes a specific file by its unique identifier.
   * @param productId The ID of the product.
   * @param fileId The ID of the file.
   * @return If the file is successfully deleted.
   */
  deleteFile(productId: string, fileId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/files/{fileId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.");
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteFile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteFile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteFile(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the file or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves the list of the entire price history.
   * @param productId The ID of the product for prices to retrieve.
   * @param pageNumber (optional)
   * @param pageSize (optional)
   * @param minPrice (optional)
   * @param maxPrice (optional)
   * @param startDate (optional)
   * @param endDate (optional)
   * @param orderBy (optional)
   * @return Returns the list of prices.
   */
  getPricesHistoryForProduct(productId: string, pageNumber?: number | undefined, pageSize?: number | undefined, minPrice?: number | null | undefined, maxPrice?: number | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, orderBy?: string | null | undefined): Observable<PriceHistoryDto[]> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history?";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (minPrice !== undefined && minPrice !== null)
      url_ += "MinPrice=" + encodeURIComponent("" + minPrice) + "&";
    if (maxPrice !== undefined && maxPrice !== null)
      url_ += "MaxPrice=" + encodeURIComponent("" + maxPrice) + "&";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPricesHistoryForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPricesHistoryForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PriceHistoryDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PriceHistoryDto[]>;
    }));
  }

  protected processGetPricesHistoryForProduct(response: HttpResponseBase): Observable<PriceHistoryDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PriceHistoryDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the price history parameters validation fails.", status, _responseText, _headers, result422);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves the list of the entire price history.
   * @param productId The ID of the product for prices to retrieve.
   * @param pageNumber (optional)
   * @param pageSize (optional)
   * @param minPrice (optional)
   * @param maxPrice (optional)
   * @param startDate (optional)
   * @param endDate (optional)
   * @param orderBy (optional)
   * @return Returns the list of prices.
   */
  pricesHistoryAll(productId: string, pageNumber?: number | undefined, pageSize?: number | undefined, minPrice?: number | null | undefined, maxPrice?: number | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, orderBy?: string | null | undefined): Observable<PriceHistoryDto[]> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history?";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (minPrice !== undefined && minPrice !== null)
      url_ += "MinPrice=" + encodeURIComponent("" + minPrice) + "&";
    if (maxPrice !== undefined && maxPrice !== null)
      url_ += "MaxPrice=" + encodeURIComponent("" + maxPrice) + "&";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("head", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processPricesHistoryAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPricesHistoryAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PriceHistoryDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PriceHistoryDto[]>;
    }));
  }

  protected processPricesHistoryAll(response: HttpResponseBase): Observable<PriceHistoryDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PriceHistoryDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the price history parameters validation fails.", status, _responseText, _headers, result422);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Creates a new price.
   * @param productId The ID of the product for price history.
   * @param body (optional) The created price hsitory information
   * @return Returns the newly created item
   */
  createPriceHistoryForProduct(productId: string, body?: CreatePriceHistoryDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processCreatePriceHistoryForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreatePriceHistoryForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreatePriceHistoryForProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated price is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("f the model is invalid or the price history information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Returns an Allow header containing the allowable HTTP methods.
   * @return Success
   */
  pricesHistory(productId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("options", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processPricesHistory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPricesHistory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processPricesHistory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves the list of the entire price history for a product based on its product ID.
   * @param productId The ID of the product for pirce history to retrieve.
   * @param priceHistoryId The ID of the category price history.
   * @return Returns the requested price history.
   */
  getPriceHistoryForProduct(productId: string, priceHistoryId: string): Observable<PriceHistoryDto> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history/{priceHistoryId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (priceHistoryId === undefined || priceHistoryId === null)
      throw new Error("The parameter 'priceHistoryId' must be defined.");
    url_ = url_.replace("{priceHistoryId}", encodeURIComponent("" + priceHistoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPriceHistoryForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPriceHistoryForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PriceHistoryDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PriceHistoryDto>;
    }));
  }

  protected processGetPriceHistoryForProduct(response: HttpResponseBase): Observable<PriceHistoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PriceHistoryDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the price history or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Updates a specific price by its unique identifier.
   * @param productId The ID of the product to update.
   * @param priceHistoryId The ID of the price history to update.
   * @param body (optional) The updated price history information.
   * @return If the price history is successfully updated.
   */
  updatePriceHistoryForProduct(productId: string, priceHistoryId: string, body?: UpdatePriceHistoryDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history/{priceHistoryId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (priceHistoryId === undefined || priceHistoryId === null)
      throw new Error("The parameter 'priceHistoryId' must be defined.");
    url_ = url_.replace("{priceHistoryId}", encodeURIComponent("" + priceHistoryId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdatePriceHistoryForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdatePriceHistoryForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdatePriceHistoryForProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated price history is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product or price history with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid or the price history information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Deletes a specific price by its unique identifier.
   * @param productId The ID of the product for prices.
   * @param priceHistoryId The ID of the price history to delete.
   * @return If the price history is successfully deleted.
   */
  deletePriceHistoryForProduct(productId: string, priceHistoryId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/prices-history/{priceHistoryId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (priceHistoryId === undefined || priceHistoryId === null)
      throw new Error("The parameter 'priceHistoryId' must be defined.");
    url_ = url_.replace("{priceHistoryId}", encodeURIComponent("" + priceHistoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processDeletePriceHistoryForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeletePriceHistoryForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeletePriceHistoryForProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the price history or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Gets the list of all products by category.
   * @param categoryId The ID of the category for products to retrieve.
   * @param pageNumber (optional)
   * @param pageSize (optional)
   * @param maxPrice (optional)
   * @param minPrice (optional)
   * @param searchTerm (optional)
   * @param orderBy (optional)
   * @return Returns the list of products.
   */
  getProductsForCategory(categoryId: string, pageNumber?: number | undefined, pageSize?: number | undefined, maxPrice?: number | null | undefined, minPrice?: number | null | undefined, searchTerm?: string | null | undefined, orderBy?: string | null | undefined): Observable<ProductDto[]> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products?";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (maxPrice !== undefined && maxPrice !== null)
      url_ += "MaxPrice=" + encodeURIComponent("" + maxPrice) + "&";
    if (minPrice !== undefined && minPrice !== null)
      url_ += "MinPrice=" + encodeURIComponent("" + minPrice) + "&";
    if (searchTerm !== undefined && searchTerm !== null)
      url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetProductsForCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetProductsForCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProductDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProductDto[]>;
    }));
  }

  protected processGetProductsForCategory(response: HttpResponseBase): Observable<ProductDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ProductDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the category with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the product parameters validation fails", status, _responseText, _headers, result422);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Gets the list of all products by category.
   * @param categoryId The ID of the category for products to retrieve.
   * @param pageNumber (optional)
   * @param pageSize (optional)
   * @param maxPrice (optional)
   * @param minPrice (optional)
   * @param searchTerm (optional)
   * @param orderBy (optional)
   * @return Returns the list of products.
   */
  productsAll(categoryId: string, pageNumber?: number | undefined, pageSize?: number | undefined, maxPrice?: number | null | undefined, minPrice?: number | null | undefined, searchTerm?: string | null | undefined, orderBy?: string | null | undefined): Observable<ProductDto[]> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products?";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (maxPrice !== undefined && maxPrice !== null)
      url_ += "MaxPrice=" + encodeURIComponent("" + maxPrice) + "&";
    if (minPrice !== undefined && minPrice !== null)
      url_ += "MinPrice=" + encodeURIComponent("" + minPrice) + "&";
    if (searchTerm !== undefined && searchTerm !== null)
      url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("head", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processProductsAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processProductsAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProductDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProductDto[]>;
    }));
  }

  protected processProductsAll(response: HttpResponseBase): Observable<ProductDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ProductDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the category with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the product parameters validation fails", status, _responseText, _headers, result422);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Creates a new product.
   * @param categoryId The ID of the category for product.
   * @param body (optional) The created rproduct information
   * @return Returns the newly created item
   */
  createProductForCategory(categoryId: string, body?: CreateProductDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateProductForCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateProductForCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateProductForCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated product is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid or the product information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Returns an Allow header containing the allowable HTTP methods.
   * @return Success
   */
  products(categoryId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("options", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processProducts(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processProducts(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processProducts(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves a specific product by its unique identifier.
   * @param categoryId The ID of the category for product to retrieve.
   * @param productId The ID of the product to retrieve.
   * @return Returns the requested product.
   */
  getProductForCategory(categoryId: string, productId: string): Observable<ProductDto> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products/{productId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetProductForCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetProductForCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProductDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProductDto>;
    }));
  }

  protected processGetProductForCategory(response: HttpResponseBase): Observable<ProductDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProductDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the cateogry or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Updates a specific product by its unique identifier.
   * @param categoryId The ID of the category for product.
   * @param productId The ID of the product to update.
   * @param body (optional) The updated product information.
   * @return If the product is successfully updated.
   */
  updateProductForCategory(categoryId: string, productId: string, body?: UpdateProductDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products/{productId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateProductForCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateProductForCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateProductForCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated product is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the cateogry or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid or the product information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Deletes a specific product by its unique identifier.
   * @param categoryId The ID of the category for product.
   * @param productId The ID of the product to delete.
   * @return If the product is successfully deleted.
   */
  deleteProductForCategory(categoryId: string, productId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/categories/{categoryId}/products/{productId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteProductForCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteProductForCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteProductForCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product or category with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Gets the list of all reviews by product.
   * @param productId The ID of the product for reviews to retrieve.
   * @param pageNumber (optional)
   * @param pageSize (optional)
   * @param rating (optional)
   * @param startDate (optional)
   * @param endDate (optional)
   * @param orderBy (optional)
   * @return Returns the list of reviews.
   */
  getReviewsForProduct(productId: string, pageNumber?: number | undefined, pageSize?: number | undefined, rating?: number | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, orderBy?: string | null | undefined): Observable<ReviewDto[]> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews?";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (rating !== undefined && rating !== null)
      url_ += "Rating=" + encodeURIComponent("" + rating) + "&";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetReviewsForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetReviewsForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ReviewDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ReviewDto[]>;
    }));
  }

  protected processGetReviewsForProduct(response: HttpResponseBase): Observable<ReviewDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ReviewDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the review parameters validation fails.", status, _responseText, _headers, result422);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Gets the list of all reviews by product.
   * @param productId The ID of the product for reviews to retrieve.
   * @param pageNumber (optional)
   * @param pageSize (optional)
   * @param rating (optional)
   * @param startDate (optional)
   * @param endDate (optional)
   * @param orderBy (optional)
   * @return Returns the list of reviews.
   */
  reviewsAll(productId: string, pageNumber?: number | undefined, pageSize?: number | undefined, rating?: number | null | undefined, startDate?: Date | null | undefined, endDate?: Date | null | undefined, orderBy?: string | null | undefined): Observable<ReviewDto[]> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews?";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (rating !== undefined && rating !== null)
      url_ += "Rating=" + encodeURIComponent("" + rating) + "&";
    if (startDate !== undefined && startDate !== null)
      url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
    if (endDate !== undefined && endDate !== null)
      url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
    if (orderBy !== undefined && orderBy !== null)
      url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("head", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processReviewsAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processReviewsAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ReviewDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ReviewDto[]>;
    }));
  }

  protected processReviewsAll(response: HttpResponseBase): Observable<ReviewDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ReviewDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the review parameters validation fails.", status, _responseText, _headers, result422);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Creates a new review.
   * @param productId The ID of the product for review.
   * @param body (optional) The created review information
   * @return Returns the newly created item.
   */
  createReviewForProduct(productId: string, body?: CreateReviewDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateReviewForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateReviewForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateReviewForProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated review is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid or the review information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Returns an Allow header containing the allowable HTTP methods.
   * @return Success
   */
  reviews(productId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("options", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processReviews(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processReviews(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processReviews(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves a specific review by its unique identifier.
   * @param productId The ID of the product for review to retrieve.
   * @param reviewId The ID of the review.
   * @return Returns the requested review.
   */
  getReviewForProduct(productId: string, reviewId: string): Observable<ProductDto> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews/{reviewId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (reviewId === undefined || reviewId === null)
      throw new Error("The parameter 'reviewId' must be defined.");
    url_ = url_.replace("{reviewId}", encodeURIComponent("" + reviewId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetReviewForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetReviewForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProductDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProductDto>;
    }));
  }

  protected processGetReviewForProduct(response: HttpResponseBase): Observable<ProductDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProductDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the review or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Updates a specific review by its unique identifier.
   * @param productId The ID of the product for review.
   * @param reviewId The ID of the review to update.
   * @param body (optional) The updated review information.
   * @return If the review is successfully updated.
   */
  updateReviewForProduct(productId: string, reviewId: string, body?: UpdateReviewDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews/{reviewId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (reviewId === undefined || reviewId === null)
      throw new Error("The parameter 'reviewId' must be defined.");
    url_ = url_.replace("{reviewId}", encodeURIComponent("" + reviewId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateReviewForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateReviewForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateReviewForProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("If the updated review is null.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the review or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result422: any = null;
        let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result422 = ProblemDetails.fromJS(resultData422);
        return throwException("If the model is invalid or the review information is incomplete.", status, _responseText, _headers, result422);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Deletes a specific review by its unique identifier.
   * @param productId The ID of the product for reviews.
   * @param reviewId The ID of the product to delete.
   * @return If the review is successfully deleted.
   */
  deleteReviewForProduct(productId: string, reviewId: string): Observable<void> {
    let url_ = this.baseUrl + "/api/products/{productId}/reviews/{reviewId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (reviewId === undefined || reviewId === null)
      throw new Error("The parameter 'reviewId' must be defined.");
    url_ = url_.replace("{reviewId}", encodeURIComponent("" + reviewId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteReviewForProduct(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteReviewForProduct(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteReviewForProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("If the review or product with the given ID is not found.", status, _responseText, _headers, result404);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ProblemDetails.fromJS(resultData401);
        return throwException("If the request lacks valid authentication credentials.", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Retrieves the root information of the API.
   * @param accept (optional)
   * @return Success
   */
  getRoot(accept?: string | undefined): Observable<Link[]> {
    let url_ = this.baseUrl + "/api";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": accept !== undefined && accept !== null ? "" + accept : "",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetRoot(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetRoot(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Link[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Link[]>;
    }));
  }

  protected processGetRoot(response: HttpResponseBase): Observable<Link[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Link.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("No Content", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export class Category implements ICategory {
  id?: string;
  categoryName?: string | null;

  constructor(data?: ICategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === 'object' ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
    return data;
  }
}

export interface ICategory {
  id?: string;
  categoryName?: string | null;
}

export class CreateCategoryDto implements ICreateCategoryDto {
  categoryName!: string;

  constructor(data?: ICreateCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
    }
  }

  static fromJS(data: any): CreateCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
    return data;
  }
}

export interface ICreateCategoryDto {
  categoryName: string;
}

export class CreatePriceHistoryDto implements ICreatePriceHistoryDto {
  startDate!: Date;
  endDate!: Date;
  priceValue?: number;

  constructor(data?: ICreatePriceHistoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
      this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
      this.priceValue = _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
    }
  }

  static fromJS(data: any): CreatePriceHistoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreatePriceHistoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
    data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
    data["priceValue"] = this.priceValue !== undefined ? this.priceValue : <any>null;
    return data;
  }
}

export interface ICreatePriceHistoryDto {
  startDate: Date;
  endDate: Date;
  priceValue?: number;
}

export class CreateProductDto implements ICreateProductDto {
  productName!: string;
  serialNumber!: string;
  price?: number;
  stock?: number;
  description!: string;
  color?: string | null;
  weight?: number;
  size?: string | null;

  constructor(data?: ICreateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.serialNumber = _data["serialNumber"] !== undefined ? _data["serialNumber"] : <any>null;
      this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
      this.stock = _data["stock"] !== undefined ? _data["stock"] : <any>null;
      this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
      this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
      this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
      this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
    }
  }

  static fromJS(data: any): CreateProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["productName"] = this.productName !== undefined ? this.productName : <any>null;
    data["serialNumber"] = this.serialNumber !== undefined ? this.serialNumber : <any>null;
    data["price"] = this.price !== undefined ? this.price : <any>null;
    data["stock"] = this.stock !== undefined ? this.stock : <any>null;
    data["description"] = this.description !== undefined ? this.description : <any>null;
    data["color"] = this.color !== undefined ? this.color : <any>null;
    data["weight"] = this.weight !== undefined ? this.weight : <any>null;
    data["size"] = this.size !== undefined ? this.size : <any>null;
    return data;
  }
}

export interface ICreateProductDto {
  productName: string;
  serialNumber: string;
  price?: number;
  stock?: number;
  description: string;
  color?: string | null;
  weight?: number;
  size?: string | null;
}

export class CreateReviewDto implements ICreateReviewDto {
  description!: string;
  rating?: number;

  constructor(data?: ICreateReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
      this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
    }
  }

  static fromJS(data: any): CreateReviewDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateReviewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["description"] = this.description !== undefined ? this.description : <any>null;
    data["rating"] = this.rating !== undefined ? this.rating : <any>null;
    return data;
  }
}

export interface ICreateReviewDto {
  description: string;
  rating?: number;
}

export class Link implements ILink {
  href?: string | null;
  rel?: string | null;
  method?: string | null;

  constructor(data?: ILink) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.href = _data["href"] !== undefined ? _data["href"] : <any>null;
      this.rel = _data["rel"] !== undefined ? _data["rel"] : <any>null;
      this.method = _data["method"] !== undefined ? _data["method"] : <any>null;
    }
  }

  static fromJS(data: any): Link {
    data = typeof data === 'object' ? data : {};
    let result = new Link();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["href"] = this.href !== undefined ? this.href : <any>null;
    data["rel"] = this.rel !== undefined ? this.rel : <any>null;
    data["method"] = this.method !== undefined ? this.method : <any>null;
    return data;
  }
}

export interface ILink {
  href?: string | null;
  rel?: string | null;
  method?: string | null;
}

export class PriceHistoryDto implements IPriceHistoryDto {
  id?: string;
  startDate?: Date;
  endDate?: Date;
  priceValue?: number;

  constructor(data?: IPriceHistoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
      this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
      this.priceValue = _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
    }
  }

  static fromJS(data: any): PriceHistoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceHistoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
    data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
    data["priceValue"] = this.priceValue !== undefined ? this.priceValue : <any>null;
    return data;
  }
}

export interface IPriceHistoryDto {
  id?: string;
  startDate?: Date;
  endDate?: Date;
  priceValue?: number;
}

export class PriceHistoryParameters implements IPriceHistoryParameters {
  pageNumber?: number;
  pageSize?: number;
  minPrice?: number | null;
  maxPrice?: number | null;
  startDate?: Date | null;
  endDate?: Date | null;
  orderBy?: string | null;

  constructor(data?: IPriceHistoryParameters) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
      this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
      this.minPrice = _data["minPrice"] !== undefined ? _data["minPrice"] : <any>null;
      this.maxPrice = _data["maxPrice"] !== undefined ? _data["maxPrice"] : <any>null;
      this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
      this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
      this.orderBy = _data["orderBy"] !== undefined ? _data["orderBy"] : <any>null;
    }
  }

  static fromJS(data: any): PriceHistoryParameters {
    data = typeof data === 'object' ? data : {};
    let result = new PriceHistoryParameters();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
    data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
    data["minPrice"] = this.minPrice !== undefined ? this.minPrice : <any>null;
    data["maxPrice"] = this.maxPrice !== undefined ? this.maxPrice : <any>null;
    data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
    data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
    data["orderBy"] = this.orderBy !== undefined ? this.orderBy : <any>null;
    return data;
  }
}

export interface IPriceHistoryParameters {
  pageNumber?: number;
  pageSize?: number;
  minPrice?: number | null;
  maxPrice?: number | null;
  startDate?: Date | null;
  endDate?: Date | null;
  orderBy?: string | null;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property))
          this[property] = _data[property];
      }
      this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
      this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
      this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
      this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
      this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property))
        data[property] = this[property];
    }
    data["type"] = this.type !== undefined ? this.type : <any>null;
    data["title"] = this.title !== undefined ? this.title : <any>null;
    data["status"] = this.status !== undefined ? this.status : <any>null;
    data["detail"] = this.detail !== undefined ? this.detail : <any>null;
    data["instance"] = this.instance !== undefined ? this.instance : <any>null;
    return data;
  }
}

export interface IProblemDetails {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;

  [key: string]: any;
}

export class ProductDto implements IProductDto {
  id?: string;
  productName?: string | null;
  serialNumber?: string | null;
  imageUris?: string[] | null;
  price?: number;
  stock?: number;
  description?: string | null;
  color?: string | null;
  weight?: number;
  size?: string | null;

  constructor(data?: IProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.serialNumber = _data["serialNumber"] !== undefined ? _data["serialNumber"] : <any>null;
      if (Array.isArray(_data["imageUris"])) {
        this.imageUris = [] as any;
        for (let item of _data["imageUris"])
          this.imageUris!.push(item);
      }
      else {
        this.imageUris = <any>null;
      }
      this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
      this.stock = _data["stock"] !== undefined ? _data["stock"] : <any>null;
      this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
      this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
      this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
      this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
    }
  }

  static fromJS(data: any): ProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["productName"] = this.productName !== undefined ? this.productName : <any>null;
    data["serialNumber"] = this.serialNumber !== undefined ? this.serialNumber : <any>null;
    if (Array.isArray(this.imageUris)) {
      data["imageUris"] = [];
      for (let item of this.imageUris)
        data["imageUris"].push(item);
    }
    data["price"] = this.price !== undefined ? this.price : <any>null;
    data["stock"] = this.stock !== undefined ? this.stock : <any>null;
    data["description"] = this.description !== undefined ? this.description : <any>null;
    data["color"] = this.color !== undefined ? this.color : <any>null;
    data["weight"] = this.weight !== undefined ? this.weight : <any>null;
    data["size"] = this.size !== undefined ? this.size : <any>null;
    return data;
  }
}

export interface IProductDto {
  id?: string;
  productName?: string | null;
  serialNumber?: string | null;
  imageUris?: string[] | null;
  price?: number;
  stock?: number;
  description?: string | null;
  color?: string | null;
  weight?: number;
  size?: string | null;
}

export class ProductParameters implements IProductParameters {
  pageNumber?: number;
  pageSize?: number;
  maxPrice?: number | null;
  minPrice?: number | null;
  searchTerm?: string | null;
  orderBy?: string | null;

  constructor(data?: IProductParameters) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
      this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
      this.maxPrice = _data["maxPrice"] !== undefined ? _data["maxPrice"] : <any>null;
      this.minPrice = _data["minPrice"] !== undefined ? _data["minPrice"] : <any>null;
      this.searchTerm = _data["searchTerm"] !== undefined ? _data["searchTerm"] : <any>null;
      this.orderBy = _data["orderBy"] !== undefined ? _data["orderBy"] : <any>null;
    }
  }

  static fromJS(data: any): ProductParameters {
    data = typeof data === 'object' ? data : {};
    let result = new ProductParameters();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
    data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
    data["maxPrice"] = this.maxPrice !== undefined ? this.maxPrice : <any>null;
    data["minPrice"] = this.minPrice !== undefined ? this.minPrice : <any>null;
    data["searchTerm"] = this.searchTerm !== undefined ? this.searchTerm : <any>null;
    data["orderBy"] = this.orderBy !== undefined ? this.orderBy : <any>null;
    return data;
  }
}

export interface IProductParameters {
  pageNumber?: number;
  pageSize?: number;
  maxPrice?: number | null;
  minPrice?: number | null;
  searchTerm?: string | null;
  orderBy?: string | null;
}

export class ReviewDto implements IReviewDto {
  id?: string;
  userName?: string | null;
  description?: string | null;
  rating?: number;
  reviewDate?: Date;

  constructor(data?: IReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
      this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
      this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
      this.reviewDate = _data["reviewDate"] ? new Date(_data["reviewDate"].toString()) : <any>null;
    }
  }

  static fromJS(data: any): ReviewDto {
    data = typeof data === 'object' ? data : {};
    let result = new ReviewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["userName"] = this.userName !== undefined ? this.userName : <any>null;
    data["description"] = this.description !== undefined ? this.description : <any>null;
    data["rating"] = this.rating !== undefined ? this.rating : <any>null;
    data["reviewDate"] = this.reviewDate ? this.reviewDate.toISOString() : <any>null;
    return data;
  }
}

export interface IReviewDto {
  id?: string;
  userName?: string | null;
  description?: string | null;
  rating?: number;
  reviewDate?: Date;
}

export class ReviewParameters implements IReviewParameters {
  pageNumber?: number;
  pageSize?: number;
  rating?: number | null;
  startDate?: Date | null;
  endDate?: Date | null;
  orderBy?: string | null;

  constructor(data?: IReviewParameters) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
      this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
      this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
      this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
      this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
      this.orderBy = _data["orderBy"] !== undefined ? _data["orderBy"] : <any>null;
    }
  }

  static fromJS(data: any): ReviewParameters {
    data = typeof data === 'object' ? data : {};
    let result = new ReviewParameters();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
    data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
    data["rating"] = this.rating !== undefined ? this.rating : <any>null;
    data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
    data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
    data["orderBy"] = this.orderBy !== undefined ? this.orderBy : <any>null;
    return data;
  }
}

export interface IReviewParameters {
  pageNumber?: number;
  pageSize?: number;
  rating?: number | null;
  startDate?: Date | null;
  endDate?: Date | null;
  orderBy?: string | null;
}

export class UpdateCategoryDto implements IUpdateCategoryDto {
  categoryName!: string;

  constructor(data?: IUpdateCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
    }
  }

  static fromJS(data: any): UpdateCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
    return data;
  }
}

export interface IUpdateCategoryDto {
  categoryName: string;
}

export class UpdatePriceHistoryDto implements IUpdatePriceHistoryDto {
  startDate!: Date;
  endDate!: Date;
  priceValue?: number;

  constructor(data?: IUpdatePriceHistoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
      this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
      this.priceValue = _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
    }
  }

  static fromJS(data: any): UpdatePriceHistoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePriceHistoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
    data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
    data["priceValue"] = this.priceValue !== undefined ? this.priceValue : <any>null;
    return data;
  }
}

export interface IUpdatePriceHistoryDto {
  startDate: Date;
  endDate: Date;
  priceValue?: number;
}

export class UpdateProductDto implements IUpdateProductDto {
  productName!: string;
  serialNumber!: string;
  price?: number;
  stock?: number;
  description!: string;
  color?: string | null;
  weight?: number;
  size?: string | null;

  constructor(data?: IUpdateProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.serialNumber = _data["serialNumber"] !== undefined ? _data["serialNumber"] : <any>null;
      this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
      this.stock = _data["stock"] !== undefined ? _data["stock"] : <any>null;
      this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
      this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
      this.weight = _data["weight"] !== undefined ? _data["weight"] : <any>null;
      this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
    }
  }

  static fromJS(data: any): UpdateProductDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["productName"] = this.productName !== undefined ? this.productName : <any>null;
    data["serialNumber"] = this.serialNumber !== undefined ? this.serialNumber : <any>null;
    data["price"] = this.price !== undefined ? this.price : <any>null;
    data["stock"] = this.stock !== undefined ? this.stock : <any>null;
    data["description"] = this.description !== undefined ? this.description : <any>null;
    data["color"] = this.color !== undefined ? this.color : <any>null;
    data["weight"] = this.weight !== undefined ? this.weight : <any>null;
    data["size"] = this.size !== undefined ? this.size : <any>null;
    return data;
  }
}

export interface IUpdateProductDto {
  productName: string;
  serialNumber: string;
  price?: number;
  stock?: number;
  description: string;
  color?: string | null;
  weight?: number;
  size?: string | null;
}

export class UpdateReviewDto implements IUpdateReviewDto {
  description!: string;
  rating?: number;

  constructor(data?: IUpdateReviewDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
      this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
    }
  }

  static fromJS(data: any): UpdateReviewDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateReviewDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["description"] = this.description !== undefined ? this.description : <any>null;
    data["rating"] = this.rating !== undefined ? this.rating : <any>null;
    return data;
  }
}

export interface IUpdateReviewDto {
  description: string;
  rating?: number;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
